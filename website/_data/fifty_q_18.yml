1:
  function: enumFromTo
  description: "Apresente uma definição recursiva da função (pré-definida) `enumFromTo :: Int -> Int -> [Int]` que constrói a lista dos números inteiros compreendidos entre dois limites."
2:
  function: enumFromThenTo
  description: "Apresente uma definição recursiva da função (pré-definida) `enumFromThenTo :: Int -> Int -> Int -> [Int]` que constrói a lista dos números inteiros compreendidos entre dois limites e espaçados de um valor constante."
3:
  function: (++)
  description: "Apresente uma definição recursiva da função (pré-definida) `(++) :: [a] -> [a] -> [a]` que concatena duas listas."
4:
  function: (!!)
  description: "Apresente uma definição recursiva da função (pré-definida) `(!!) :: [a] -> Int -> a` que dada uma lista e um inteiro, calcula o elemento da lista que se encontra nessa posição (assume-se que o primeiro elemento se encontra na posição 0).


Ignore os casos em que a função não se encontra definida (i.e., em que a posição fornecida não
corresponde a nenhuma posição válida da lista)."
5:
  function: reverse
  description: "Apresente uma definição recursiva da função (pré-definida) `reverse :: [a] -> [a]` que dada uma lista calcula uma lista com os elementos dessa lista pela ordem inversa."
6:
  function: take
  description: "Apresente uma definição recursiva da função (pré-definida) `take :: Int -> [a] -> [a]` que dado um inteiro n e uma lista l calcula a lista com os (no máximo) n primeiros elementos de l."
7:
  function: drop
  description: "Apresente uma definição recursiva da função (pré-definida) `drop :: Int -> [a] -> [a]` que dado um inteiro n e uma lista l calcula a lista sem os (no máximo) n primeiros elementos de l."
8:
  function: zip
  description: "Apresente uma definição recursiva da função (pré-definida) `zip :: [a] -> [b] -> [(a,b)]` que constrói uma lista de pares a partir de duas listas."
9:
  function: elem
  description: "Apresente uma definição recursiva da função (pré-definida) `elem :: Eq a => a -> [a] -> Bool` que testa se um elemento ocorre numa lista."
10:
  function: replicate
  description: "Apresente uma definição recursiva da função (pré-definida) `replicate :: Int -> a -> [a]` que dado um inteiro n e um elemento x constrói uma lista com n elementos, todos iguais a x."
11:
  function: intersperse
  description: "Apresente uma definição recursiva da função (pré-definida) `intersperse :: a -> [a] -> [a]` que, dado um elemento e uma lista, constrói uma lista em que o elemento fornecido é intercalado entre os elementos da lista fornecida."
12:
  function: group
  description: "Apresente uma definição recursiva da função (pré-definida) `group :: Eq a => [a] -> [[a]]` que agrupa elementos iguais e consecutivos de uma lista."
13:
  function: concat
  description: "Apresente uma definição recursiva da função (pré-definida) `concat :: [[a]] -> [a]` que concatena as listas de uma lista."
14:
  function: inits
  description: "Apresente uma definição recursiva da função (pré-definida) `inits :: [a] -> [[a]]` que calcula a lista dos prefixos de uma lista."
15:
  function: tails
  description: "Apresente uma definição recursiva da função (pré-definida) `tails :: [a] -> [[a]]` que calcula a lista dos sufixos de uma lista."
16:
  function: isPrefixOf
  description: "Apresente uma definição recursiva da função (pré-definida) `isPrefixOf :: Eq a => [a] -> [a] -> Bool` que testa se uma lista é prefixo de outra."
17:
  function: isSuffixOf
  description: "Apresente uma definição recursiva da função (pré-definida) `isSuffixOf :: Eq a => [a] -> [a] -> Bool` que testa se uma lista é sufixo de outra."
18:
  function: isSubsequenceOf
  description: "Apresente uma definição recursiva da função (pré-definida) `isSubsequenceOf :: Eq a => [a] -> [a] -> Bool` que testa se os elementos de uma lista ocorrem noutra pela mesma ordem relativa."
19:
  function: elemIndices
  description: "Apresente uma definição recursiva da função (pré-definida) `elemIndices :: Eq a => a -> [a] -> [Int]` que calcula a lista de posições em que um dado elemento ocorre numa lista."
20:
  function: nub
  description: "Apresente uma definição recursiva da função (pré-definida) `nub :: Eq a => [a] -> [a]` que calcula uma lista com os mesmos elementos da recebida, sem repetições."
21:
  function: delete
  description: "Apresente uma definição recursiva da função (pré-definida) `delete :: Eq a => a -> [a] -> [a]` que retorna a lista resultante de remover (a primeira ocorrência de) um dado elemento de uma lista."
22:
  function: (\\)
  description: "Apresente uma definição recursiva da função (pré-definida) `(\\\\) :: Eq a => [a] -> [a] -> [a]` que retorna a lista resultante de remover (as primeiras ocorrências) dos elementos da segunda lista da primeira."
23:
  function: union
  description: "Apresente uma definição recursiva da função (pré-definida) `union :: Eq a => [a] -> [a] -> [a]` que retorna a lista resultante de acrescentar à primeira lista os elementos da segunda que não ocorrem na primeira."
24:
  function: intersect
  description: "Apresente uma definição recursiva da função (pré-definida) `intersect :: Eq a => [a] -> [a] -> [a]` que retorna a lista resultante de remover da primeira lista os elementos que não pertencem à segunda."
25:
  function: insert
  description: "Apresente uma definição recursiva da função (pré-definida) `insert :: Ord a => a -> [a] -> [a]` que dado um elemento e uma lista ordenada retorna a lista resultante de inserir ordenadamente esse elemento na lista."
26:
  function: unwords
  description: "Apresente uma definição recursiva da função (pré-definida) `unwords :: [String] -> String` que junta todas as strings da lista numa só, separando-as por um espaço."
27:
  function: unlines
  description: "Apresente uma definição recursiva da função (pré-definida) `unlines :: [String] -> String` que junta todas as strings da lista numa só, separando-as pelo caracter ’\\n’."
28:
  function: pMaior
  description: "Apresente uma definição recursiva da função `pMaior :: Ord a => [a] -> Int` que dada uma lista não vazia, retorna a posição onde se encontra o maior elemento da lista. As posições da lista começam em 0, i.e., a função deverá retornar 0 se o primeiro elemento da lista for o maior."
29:
  function: temRepetidos
  description: "Apresente uma definição recursiva da função `temRepetidos :: Eq a => [a] -> Bool` que testa se uma lista tem elementos repetidos."
30:
  function: algarismos
  description: "Apresente uma definição recursiva da função àlgarismos :: [Char] -> [Char]` que determina a lista dos algarismos de uma dada lista de caracteres."
31:
  function: posImpares
  description: "Apresente uma definição recursiva da função `posImpares :: [a] -> [a]` que determina os elementos de uma lista que ocorrem em posições  ́ımpares. Considere que o primeiro elemento da lista ocorre na posição 0 e por isso par."
32:
  function: posPares
  description: "Apresente uma definição recursiva da função `posPares :: [a] -> [a]` que determina os elementos de uma lista que ocorrem em posições pares. Considere que o primeiro elemento da lista ocorre na posição 0 e por isso par."
33:
  function: isSorted
  description: "Apresente uma definição recursiva da função `isSorted :: Ord a => [a] -> Bool` que testa se uma lista está ordenada por ordem crescente."
34:
  function: iSort
  description: "Apresente uma definição recursiva da função `iSort :: Ord a => [a] -> [a]` que calcula o resultado de ordenar uma lista. Assuma, se precisar, que existe definida a função `insert :: Ord a => a -> [a] -> [a]` que dado um elemento e uma lista ordenada retorna a lista resultante de inserir ordenadamente esse elemento na lista."
35:
  function: menor
  description: "Apresente uma definição recursiva da função `menor :: String -> String -> Bool` que dadas duas strings, retorna True se e só se a primeira for menor do que a segunda, segundo a ordem lexicográfica (i.e., do dicionário)"
36:
  function: elemMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função `elemMSet :: Eq a => a -> [(a,Int)] -> Bool` que testa se um elemento pertence a um multi-conjunto."
37:
  function: lengthMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função `lengthMSet :: [(a,Int)] -> Int` que calcula o tamanho de um multi- conjunto."
38:
  function: converteMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função `converteMSet :: [(a,Int)] -> [a]` que converte um multi-conjuto na lista dos seus elementos."
39:
  function: insereMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função `insereMSet :: Eq a => a -> [(a,Int)] -> [(a,Int)]` que acrescenta um elemento a um multi-conjunto."
40:
  function: removeMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função removeMSet :: Eq a => a -> [(a,Int)] -> [(a,Int)] que remove um elemento a um multi-conjunto. Se o elemento não existir, deve ser retornado o multi-conjunto recebido."
41:
  function: constroiMSet
  description: "Considere que se usa o tipo `[(a,Int)]` para representar multi-conjuntos de elementos de a. Considere ainda que nestas listas não há pares cuja primeira componente coincida, nem cuja segunda componente seja menor ou igual a zero.

Defina a função `constroiMSet :: Ord a => [a] -> [(a,Int)]` dada uma lista ordenada por ordem crescente, calcula o multi-conjunto dos seus elementos."
42:
  function: partitionEithers
  description: "Apresente uma definição recursiva da função pré-definida `partitionEithers :: [Either a b] -> ([a],[b])` que divide uma lista de Either s em duas listas."
43:
  function: catMaybes
  description: "Apresente uma definição recursiva da função pré-definida `catMaybes :: [Maybe a] -> [a]` que coleciona os elementos do tipo a de uma lista."
44:
  function: posicao
  description: "Considere o seguinte tipo para representar movimentos de um robot.

`data Movimento = Norte | Sul | Este | Oeste`
      `deriving Show`

Defina a função `posicao :: (Int,Int) -> [Movimento] -> (Int,Int)` que, dada uma posição inicial (coordenadas) e uma lista de movimentos, calcula a posição final do robot depois de efetuar essa sequência de movimentos."
45:
  function: caminho
  description: "Considere o seguinte tipo para representar movimentos de um robot.

`data Movimento = Norte | Sul | Este | Oeste`
      `deriving Show`

Defina a função `caminho :: (Int,Int) -> (Int,Int) -> [Movimento]` que, dadas as posições inicial e final (coordenadas) do robot, produz uma lista de movimentos suficientes para que o robot passe de uma posição para a outra."
46:
  function: vertical
  description: "Considere o seguinte tipo para representar movimentos de um robot.

`data Movimento = Norte | Sul | Este | Oeste`
      `deriving Show`

Defina a função `vertical :: [Movimento] -> Bool` que, testa se uma lista de movimentos só é composta por movimentos verticais (Norte ou Sul)."
47:
  function: maisCentral
  description: "Considere o seguinte tipo para representar movimentos de um robot.

`data Movimento = Norte | Sul | Este | Oeste`
      `deriving Show`

Defina a função `maisCentral :: [Posicao] -> Posicao` que, dada uma lista não vazia de posições, determina a que está mais perto da origem (note que as coordenadas de cada ponto são números inteiros)."
48:
  function: vizinhos
  description: "Considere o seguinte tipo para representar movimentos de um robot.

`data Movimento = Norte | Sul | Este | Oeste`
      `deriving Show`

Defina a função `vizinhos :: Posicao -> [Posicao] -> [Posicao]` que, dada uma posição e uma lista de posições, seleciona da lista as posições adjacentes à posição dada."
49:
  function: mesmaOrdenada
  description: "Considere o seguinte tipo para representar movimentos de um robot.

`data Movimento = Norte | Sul | Este | Oeste`
      `deriving Show`

Defina a função `mesmaOrdenada :: [Posicao] -> Bool` que testa se todas as posições de uma dada lista têm a mesma ordenada."
50:
  function: intersecaoOK
  description: "Considere o seguinte tipo para representar o estado de um semáforo.

`data Semaforo = Verde | Amarelo | Vermelho`
        `deriving Show`

Defina a função `intersecaoOK :: [Semaforo] -> Bool` que testa se o estado dos semáforos de um cruzamento é seguro, i.e., não há mais do que semáforo não vermelho."